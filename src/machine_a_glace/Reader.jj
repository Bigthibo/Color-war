options {
DEBUG_PARSER=false;
STATIC=false;
}
PARSER_BEGIN(Reader)
package jus.aoo.lisp.kernel ;
import java.io.*;


public class Reader {

  
/** le support de lecture */
protected static java.io.Reader in;
protected static Reader parser;

/** lecture d'une S-EXPR à partir de la chaîne
* @param s : la chaîne
* @return SEXPR : la SEXPR construite.
* @throws LispException une erreur de syntaxe
*/
public static Sexpr read(String s) throws LispException{
	java.io.Reader save = in;
  in = new StringReader(s);
  Sexpr r =  read();
  in = save;
  return r;
}
/** évaluation de la séquence S-EXPRs à partir du fichier s
* @param s : le nom du fichier
* @return SEXPR : symbole du nom du fichier.
* @throws LispException une erreur de lecture
*/
public static Sexpr importe(String s) throws LispException,FileNotFoundException{
  parser.ReInit(new FileInputStream(s));
  try {  parser.SEXPRESSIONS(); }
  catch ( ParseException e) {
	throw new LispException(e);
    }
    return Symbole.newSymbole(s);
}
private Sexpr quote(Sexpr s) { return new Scons(Symbole.newSymbole("quote"),new Scons(s, Nil.Nil));}

private Sexpr quote(Sexpr s1,Sexpr s2) { return new Scons(s1,s2); }

}

PARSER_END(Reader)
// les caractères ignorés
SKIP :
{
" " | "\t" | "\r"| "\n"
// attention élimine la notion de fin de ligne
| "\u0000" | "\u0001" | "\u0002" | "\u0003" | "\u0004" | "\u0005" | "\u0006" | "\u0007"
| "\u0008" | "\u000B" | "\u000C" | "\u000E" | "\u000F" | "\u0010" | "\u0011" | "\u0012"
| "\u0013" | "\u0014" | "\u0015" | "\u0016" | "\u0017" | "\u0018" | "\u0019" | "\u001A"
| "\u001B" | "\u001C" | "\u001D" | "\u001E" | "\u001F" | "\u007F"
}
MORE :
{
"//" : IN_SL_COMMENT
| "/*" : IN_ML_COMMENT
}
<IN_SL_COMMENT> SPECIAL_TOKEN :{<SL_COMMENT: "\n" | "\r" | "\r\n"> : DEFAULT}
<IN_ML_COMMENT> SPECIAL_TOKEN :{<ML_COMMENT: "*/" > : DEFAULT}
<IN_SL_COMMENT,IN_ML_COMMENT> SKIP :{< ~[] >}// les lexèmes du langage
TOKEN :{
  < #LETTER : ["a"-"z"] | [ "A"-"Z"] >
| < #DIGIT: ["0"-"9"] >
| <LPAR : "(">
| <RPAR : ")"> 
| <QUOTE : "'">
| <DOT : ".">
| <ID : (< LETTER > | < DIGIT >)+>
}

Sexpr ATOME(): {Sexpr s1;} {s1=SYMBOLE(){ return s1;}}
Sexpr SYMBOLE(): {Token t;} {t=< ID > { return Symbole.newSymbole(t.image);}}


//SEXPR LISTE() : { } { < LPAR > ATOME() < RPAR >}
void SEXPRESSIONS() : {Sexpr s1;}{
	(s1=SEXPR(){s1.eval();})* <EOF>{}
}

Sexpr SEXPRESSION() :

{ Sexpr s1; }

{
  (s1=SEXPR() { s1 = s1.eval(); } )* < EOF >
  {
   	return Symbole.newSymbole("..."); 
  }
   < EOF >
}

Sexpr SEXPR() : { Sexpr s1;} {
  s1=ATOME(){ return s1;}
| < LPAR > s1=LISTE() < RPAR >{ return s1;}
| < QUOTE > s1=SEXPR(){ return quote(s1);}
 }

Sexpr LISTE() : {Sexpr s1,s2; } {
  s1=SEXPR()(< DOT > s2=SEXPR()| s2=LISTE()){ return new Scons(s1,s2);}
| { return Nil.Nil;}
}